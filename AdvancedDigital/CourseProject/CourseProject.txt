//odyshbayeh-1201462

//for this T-flipflop module i used the notes from the book 
//i can also define the same module by entering the clk & reset input into a and gate for the input edge timer for the T-flipflop
//as the notes describes.
module t_ff (t, clk, reset, q);
	
	input t, clk, reset;
    output reg q;

    always @(posedge clk or posedge reset)
		begin
        if (reset)
            q <= 1'b0;
        else
            q <= q ^ t;
    end

endmodule

//for this module i figured the state diagram and wrote down the state table and got the 4 equations for the circuit 
//to detect the sequence 1011 which are : T0,T1,T2,Y <== were the output from the k map and build the design structurally
module sequence_detector (clk,reset,x,y);
	
    input  clk,reset,x;
    output y;

    wire t0,t1,t2;
    reg q0,q1,q2;

    t_ff tf0 (.t(t0), .clk(clk), .reset(reset), .q(q0));
    t_ff tf1 (.t(t1), .clk(clk), .reset(reset), .q(q1));
    t_ff tf2 (.t(t2), .clk(clk), .reset(reset), .q(q2));

    assign t0 = (q0 & ~x) | (~q0 & x);
    assign t1 = (q2 & ~x) | (q1 & ~q0 & ~x) | (q1 & q0 & x) | (~q1 & q0 & ~x);
    assign t2 = q2 | (q0 & q1 & x);

    assign  y = q2;

endmodule

//this is the module for the circuit but impleminted behaviourly so that we can see the out put from the structural circuit 
// and from the behavioural circuit and compare the outputs from the modules.
module sequence_detector_behavioral(clk, reset, x, y);
    input clk, reset, x;
    output reg y;

    wire t0,t1,t2;
    reg q0,q1,q2;

    assign t0 = (q0 & ~x) | (~q0 & x);
    assign t1 = (q2 & ~x) | (q1 & ~q0 & ~x) | (q1 & q0 & x) | (~q1 & q0 & ~x);
    assign t2 = q2 | (q0 & q1 & x);

    always @(posedge clk or posedge reset)
		begin
        if (reset)
            q0 <= 1'b0;
        else
            q0 <= t0;
    end

    always @(posedge clk or posedge reset)
		begin
        if (reset)
            q1 <= 1'b0;
        else
            q1 <= t1;
    end

    always @(posedge clk or posedge reset)
		begin
        if (reset)
            q2 <= 1'b0;
        else
            q2 <= t2;
    end

    always @(posedge clk or posedge reset)
		begin
        y <= q2;
    end

endmodule

//odyshbayeh-1201462
module tb_sequence_detector();

    reg clk;
    reg reset;
    reg x;
    wire y1, y2;

    sequence_detector u1 (.clk(clk), .reset(reset), .x(x), .y(y1));
    sequence_detector_behavioral u2 (.clk(clk), .reset(reset), .x(x), .y(y2));

    initial begin
        clk = 0;
        reset = 1;
        x = 0;

        // resetting the reset input so that the TFF starts working as expected
        #5 reset = 0;
        // applying a random sequence
        x = 1;
        #20 x = 0;
        #20 x = 1;
        #20 x = 1;
        #40;
        // applying the required input delays to detect the sequence 1011
        x = 0;
        #20 x = 1;
        #20 x = 0;
        #20 x = 1;
        #40; 
		
	   #100 $finish;

    end
    always #10 clk = ~clk;

endmodule